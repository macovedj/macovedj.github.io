{"version":3,"sources":["threeRelativity/js/threeImplementation.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA","file":"threeImplementation.d406136c.map","sourceRoot":"..","sourcesContent":["// let moment = require('moment');\n// let momentDurationFormatSetup = require(\"moment-duration-format\");\n\n// let lastTime = performance.now();\n// let relativisticPhotonTime = 0;\n// let time = 0;\n// let travellerSpeed = 0;\n// let gamma = 1;\n// let playing = false;\n// let pauseTime = 5;\n// let movingLightSecondLines = [];\n// let movingSpritesA = [];\n// let movingSpritesB = [];\n// let resumeTime;\n\n// let sliderNode = document.querySelector('#speedSlider');          \n// let movingPhotonTimeNode = document.querySelector('#movingPhotonTime');          \n// let stationaryTimeNode = document.querySelector('#stationaryTime');          \n// let resetButtonNode = document.querySelector('#resetButton');          \n// let startButtonNode = document.querySelector('#startButton');          \n// let recenterXButtonNode = document.querySelector('#recenterXButton');          \n// let recenterYButtonNode = document.querySelector('#recenterYButton');          \n// let labelValue = document.querySelector('#labelValue');\n// let gammaLabel = document.querySelector('#gammaLabel');          \n// let pauseInput = document.querySelector('#pauseTime');\n\n// startButtonNode.addEventListener(\"click\", startHandler);\n// resetButtonNode.addEventListener(\"click\", resetHandler);\n// pauseInput.addEventListener(\"input\", pauseInputHandler);\n// recenterXButtonNode.addEventListener(\"click\", recenterXHandler);\n// recenterYButtonNode.addEventListener(\"click\", recenterYHandler);\n\n// function resetHandler() {\n// \tsliderNode.value = 0;\n// \tgamma = 1;\n// \trelativisticPhotonTime = 0;\n// \ttime = 0;\n// \ttravellerSpeed = 0;\n// \tmovingPhotonTimeNode.innerHTML = \"00:00:00\";\n// \tstationaryTimeNode.innerHTML = \"00:00:00\";\n// \tlabelValue.innerHTML = \"0\";\n// \tgammaLabel.innerHTML = \"1\";\n// \tmovingLineA.position.x = 0;\n// \tphotonA.position.x = 0;\n// \tmovingSpritesA.forEach(sprite => scene.remove(sprite));\n// \tmovingSpritesB.forEach(sprite => scene.remove(sprite));\n// \tmovingLightSecondLines.forEach(line => scene.remove(line));\n// \tmovingLightSecondLines = [];\n// \tmovingSpritesA = [];\n// \tmovingSpritesB = [];\n// \tpauseTime = pauseInput.value;\n// \tfor (var i = 0; i <= 200; i++) {\n// \t\tcreateMovingLightSecondA(i, gamma);\n// \t}\n// \tmovingLightSecondLines.forEach(line => scene.add(line))\n// \tmovingSpritesA.forEach(sprite => scene.add(sprite))\n// \tmovingSpritesB.forEach(sprite => scene.add(sprite))\n// \tsliderNode.disabled = false;\n// \tplaying = false;\n// }\n\n// function startHandler() {\n// \tlastTime = performance.now();\n// \tif (resumeTime) {\n// \t\ttime = resumeTime;\n// \t}\n// \tplaying = true;\n// \tsliderNode.disabled = true;\n// }\n\n// function pauseInputHandler() {\n// \tpauseTime = pauseInput.value;\n// }\n\n// // Handle Scroll Logic\n// function onMouseWheel(event) {\n// \tevent.preventDefault();\n// \tcamera.position.x += event.deltaX * 0.005;\n// \tcamera.position.y += event.deltaY * 0.005;\n\n// \t// prevent scrolling beyond a min/max value\n\n// \tcamera.position.clampScalar(-1000, 1000);\n// }\n\n// function recenterXHandler() {\n// \tcamera.position.x = 0;\n// }\n\n// function recenterYHandler() {\n// \tcamera.position.y = 0;\n// }\n\n// function createStationaryLightSecondA(i) {\n// \tvar lightSecondMark = new THREE.Geometry();\n// \tlightSecondMark.vertices.push(new THREE.Vector3( i * 1.5, .9, 0));\n// \tlightSecondMark.vertices.push(new THREE.Vector3( i * 1.5, 1.1, 0));\n// \tvar lightSecondLine = new THREE.LineSegments( lightSecondMark, linesMaterial );\n// \tlet canvas = document.createElement('canvas');\n// \tcanvas.width = 256;\n// \tcanvas.height = 256;\n// \tvar ctx = canvas.getContext(\"2d\");\n// \tctx.font = \"22pt Arial\";\n// \tctx.fillStyle = \"#9f8ec2\";\n// \tctx.textAlign = \"center\";\n// \tctx.fillText(i, 128, 44);\n// \tvar tex = new THREE.Texture(canvas);\n// \ttex.needsUpdate = true;\n// \tvar spriteMat = new THREE.SpriteMaterial({\n// \t\tmap: tex\n// \t});\n// \tvar sprite = new THREE.Sprite(spriteMat);\n// \tsprite.position.x = i * 1.5;\n// \tsprite.position.y = 0.4;\n// \tscene.add(lightSecondLine);\n// \tscene.add(sprite);\n// }\n\n// function createStationaryLightSecondB(i) {\n// \tvar lightSecondMark = new THREE.Geometry();\n// \tlightSecondMark.vertices.push(new THREE.Vector3(i * 1.5, -.6, 0));\n// \tlightSecondMark.vertices.push(new THREE.Vector3(i * 1.5, -.4, 0));\n// \tvar lightSecondLine = new THREE.LineSegments(lightSecondMark, movingLinesMaterial);\n// \tlet canvas = document.createElement('canvas');\n// \tcanvas.width = 256;\n// \tcanvas.height = 256;\n// \tvar ctx = canvas.getContext(\"2d\");\n// \tctx.font = \"22pt Arial\";\n// \tctx.fillStyle = \"#5f9ea0\";\n// \tctx.textAlign = \"center\";\n// \tctx.fillText(i, 128, 44);\n// \tvar tex = new THREE.Texture(canvas);\n// \ttex.needsUpdate = true;\n// \tvar spriteMat = new THREE.SpriteMaterial({\n// \t\tmap: tex\n// \t});\n// \tvar sprite = new THREE.Sprite(spriteMat);\n// \tsprite.position.x = i * 1.5;\n// \tsprite.position.y = -1.1;\n// \tscene.add(lightSecondLine);\n// \tscene.add(sprite);\n// }\n\n// function createMovingLightSecondA(i, gamma) {\n// \tvar movingLightSecondMark = new THREE.Geometry();\n// \tmovingLightSecondMark.vertices.push(new THREE.Vector3( i * 1.5 / gamma, 1.4, 0));\n// \tmovingLightSecondMark.vertices.push(new THREE.Vector3( i * 1.5 / gamma, 1.6, 0));\n// \tvar movingLightSecondLine = new THREE.LineSegments( movingLightSecondMark, movingLinesMaterial );\n// \tmovingLightSecondLines.push(movingLightSecondLine);\n// \tlet canvas = document.createElement('canvas');\n// \tcanvas.width = 256;\n// \tcanvas.height = 256;\n// \tvar ctx = canvas.getContext(\"2d\");\n// \tctx.font = \"22pt Arial\";\n// \tctx.fillStyle = \"#5f9ea0\";\n// \tctx.textAlign = \"center\";\n// \tctx.fillText(i, 128, 44);\n// \tvar tex = new THREE.Texture(canvas);\n// \ttex.needsUpdate = true;\n// \tvar spriteMat = new THREE.SpriteMaterial({\n// \t\tmap: tex\n// \t});\n// \tvar sprite = new THREE.Sprite(spriteMat);\n// \tsprite.position.x = i * 1.5 / gamma;\n// \tsprite.position.y = .9;\n// \tmovingSpritesA.push(sprite);\n// }\n\n// function createMovingLightSecondB(i, gamma) {\n// \tvar movingLightSecondMark = new THREE.Geometry();\n// \tmovingLightSecondMark.vertices.push(new THREE.Vector3(i * 1.5 / gamma, -1.1, 0));\n// \tmovingLightSecondMark.vertices.push(new THREE.Vector3(i * 1.5 / gamma, -.9, 0));\n// \tvar movingLightSecondLine = new THREE.LineSegments(movingLightSecondMark, linesMaterial);\n// \tmovingLightSecondLines.push(movingLightSecondLine);\n// \tlet canvas = document.createElement('canvas');\n// \tcanvas.width = 256;\n// \tcanvas.height = 256;\n// \tvar ctx = canvas.getContext(\"2d\");\n// \tctx.font = \"22pt Arial\";\n// \tctx.fillStyle = \"#9f8ec2\";\n// \tctx.textAlign = \"center\";\n// \tctx.fillText(i, 128, 44);\n// \tvar tex = new THREE.Texture(canvas);\n// \ttex.needsUpdate = true;\n// \tvar spriteMat = new THREE.SpriteMaterial({\n// \t\tmap: tex\n// \t});\n// \tvar sprite = new THREE.Sprite(spriteMat);\n// \tsprite.position.x = i * 1.5 / gamma;\n// \tsprite.position.y = -1.6;\n// \tmovingSpritesB.push(sprite);\n// }\n\n// // Establish the scene\n// var scene = new THREE.Scene();\n// var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\n// var renderer = new THREE.WebGLRenderer();\n// renderer.setClearColor(0x333333);\n// renderer.setSize(window.innerWidth, window.innerHeight);\n// document.body.appendChild(renderer.domElement);\n\n// window.addEventListener('wheel', onMouseWheel, false);\n// window.addEventListener('resize', function () {\n// \tvar width = window.innerWidth;\n// \tvar height = window.innerHeight;\n// \trenderer.setSize(width, height);\n// \tcamera.aspect = width / height;\n// \tcamera.updateProjectionMatrix();\n// });\n\n// function computeGamma() { return 1/ Math.sqrt(1 - Math.pow(travellerSpeed, 2)); }\n\n// const renderTimers= (time, relativisticPhotonTime) => {\n// \tmovingPhotonTimeNode.innerText = moment.duration(relativisticPhotonTime).format('mm:ss:SS', { trim: false });\n// \tstationaryTimeNode.innerText = moment.duration(time).format('mm:ss:SS', { trim: false });\n// }\n\n// sliderNode.addEventListener(\"input\", ev => {\n// \ttravellerSpeed = ev.target.value;\n// \tlabelValue.innerHTML = sliderNode.value;\n// \tgamma = computeGamma();\n// \tgammaLabel.innerHTML = gamma;\n// \tmovingLightSecondLines.forEach(line => line.scale.set(1 / gamma, 1, 1)) \n// \tmovingSpritesA.forEach((sprite, i) => sprite.position.x = movingSpritesA[0].position.x + i * 1.5 / gamma);\n// \tmovingSpritesB.forEach((sprite, i) => sprite.position.x = movingSpritesB[0].position.x + i * 1.5 / gamma);\n// })\n\n// // Create each measurement line and photon\n// var stationaryGeometryA = new THREE.Geometry();\n// var movingGeometryA = new THREE.Geometry();\n// var photonGeometryA = new THREE.PlaneGeometry(.05,.05,.05);\n\n// var stationaryGeometryB = new THREE.Geometry();\n// var movingGeometryB = new THREE.Geometry();\n// var photonGeometryB = new THREE.PlaneGeometry(.05, .05, .05);\n\n// stationaryGeometryA.vertices.push(new THREE.Vector3( -1000, 1, 0) );\n// stationaryGeometryA.vertices.push(new THREE.Vector3( 1000, 1, 0) );\n// movingGeometryA.vertices.push(new THREE.Vector3( -1000, 1.5, 0) );\n// movingGeometryA.vertices.push(new THREE.Vector3( 1000, 1.5, 0) );\n\n// stationaryGeometryB.vertices.push(new THREE.Vector3(-1000, -1, 0));\n// stationaryGeometryB.vertices.push(new THREE.Vector3(1000, -1, 0));\n// movingGeometryB.vertices.push(new THREE.Vector3(-1000, -.5, 0));\n// movingGeometryB.vertices.push(new THREE.Vector3(1000, -.5, 0));\n\n// const linesMaterial = new THREE.LineBasicMaterial( { color: 0x9f8ec2 } );\n// const movingLinesMaterial = new THREE.LineBasicMaterial( { color: 0x5f9ea0 } );\n\n// // Create tick marks on each line\n// for ( var i = 0; i <= 200; i++ ) {\n// \tcreateStationaryLightSecondA(i);\n// \tcreateMovingLightSecondA(i, gamma);\n// \tcreateStationaryLightSecondB(i);\n// \tcreateMovingLightSecondB(i, gamma);\n// }\n// movingLightSecondLines.forEach(mark => scene.add(mark));\n// movingSpritesA.forEach(sprite => scene.add(sprite));\n// movingSpritesB.forEach(sprite => scene.add(sprite));\n\n// // create materials for various geometries\n// var stationaryMaterial = new THREE.LineBasicMaterial( { color: 0x9f8ec2 } );\n// var movingMaterial = new THREE.LineBasicMaterial( { color: 0x5f9ea0 } );\n// const photonMaterial = new THREE.MeshBasicMaterial( { color: 0xffe623, side: THREE.DoubleSide } );\n\n// var stationaryLineA = new THREE.Line( stationaryGeometryA, stationaryMaterial );\n// var movingLineA = new THREE.Line( movingGeometryA, movingMaterial );\n// var photonA = new THREE.Mesh( photonGeometryA, photonMaterial );\n// photonA.position.y = 2;\n\n// var stationaryLineB = new THREE.Line(stationaryGeometryB, stationaryMaterial);\n// var movingLineB = new THREE.Line(movingGeometryB, movingMaterial);\n// var photonB = new THREE.Mesh(photonGeometryB, photonMaterial);\n// photonB.position.y = 0;\n// camera.position.z = 3;\n\n// scene.add(stationaryLineA);\n// scene.add(movingLineA);\n// scene.add(photonA);\n\n// scene.add(stationaryLineB);\n// scene.add(movingLineB);\n// scene.add(photonB);\n\n// // update logic\n// var update = function() {\n// \t//stop after pause time\n// \tif (time > pauseTime * 1000) {\n// \t\tplaying = false\n// \t}\n\t\n// \t//update positions and times if not paused\n// \tif (playing) {\n// \t\tconst now = performance.now();\n// \t\tconst sinceLast = now - lastTime;\n// \t\ttime += sinceLast;\n// \t\trelativisticPhotonTime = gamma * (time * ( 1 - travellerSpeed));\n// \t\trenderTimers( time, relativisticPhotonTime );\n// \t\tlastTime = now;\n// \t\tmovingLightSecondLines.forEach(line =>  line.position.x += travellerSpeed * sinceLast * .0015);\n// \t\tmovingSpritesA.forEach(sprite =>  sprite.position.x += travellerSpeed * sinceLast * .0015);\n// \t\tphotonA.position.x += 1.5 * sinceLast / 1000\n// \t}\n// }\t\n\n// // draw Scene\n// var render = function() {\n//     renderer.render(scene, camera);\n// };\n\n// // run game loop (update, render, repeate)\n// var GameLoop = function() {\n//   update();\n//   render();\n//   requestAnimationFrame( GameLoop );\n// };\n\n// GameLoop();"]}